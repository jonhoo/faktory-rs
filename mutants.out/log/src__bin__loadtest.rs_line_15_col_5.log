
*** src/bin/loadtest.rs:15:5: replace main with ()

*** mutation diff:
--- src/bin/loadtest.rs
+++ replace main with ()
@@ -7,113 +7,10 @@
 use std::sync::{self, atomic};
 use std::time;
 use tokio::task;
 
 const QUEUES: &[&str] = &["queue0", "queue1", "queue2", "queue3", "queue4"];
 
 #[tokio::main]
 async fn main() {
-    let matches = Command::new("My Super Program (Async)")
-        .version("0.1")
-        .about("Benchmark the performance of Rust Faktory async workers and client")
-        .arg(
-            Arg::new("jobs")
-                .help("Number of jobs to run")
-                .value_parser(value_parser!(usize))
-                .index(1)
-                .default_value("30000"),
-        )
-        .arg(
-            Arg::new("threads")
-                .help("Number of workers/clients to run")
-                .value_parser(value_parser!(usize))
-                .index(2)
-                .default_value("10"),
-        )
-        .get_matches();
-
-    let jobs: usize = *matches.get_one("jobs").expect("default_value is set");
-    let threads: usize = *matches.get_one("threads").expect("default_value is set");
-    println!(
-        "Running loadtest with {} jobs and {} threads",
-        jobs, threads
-    );
-
-    // ensure that we can actually connect to the server;
-    // will create a client, run a handshake with Faktory,
-    // and drop the cliet immediately afterwards;
-    if let Err(e) = Client::connect(None).await {
-        println!("{}", e);
-        process::exit(1);
-    }
-
-    let pushed = sync::Arc::new(atomic::AtomicUsize::new(0));
-    let popped = sync::Arc::new(atomic::AtomicUsize::new(0));
-
-    let start = time::Instant::now();
-
-    let mut set = task::JoinSet::new();
-    for _ in 0..threads {
-        let pushed = sync::Arc::clone(&pushed);
-        let popped = sync::Arc::clone(&popped);
-        set.spawn(async move {
-            // make producer and consumer
-            let mut p = Client::connect(None).await.unwrap();
-            let mut c = WorkerBuilder::default();
-            c.register("SomeJob", |_| {
-                Box::pin(async move {
-                    let mut rng = rand::thread_rng();
-                    if rng.gen_bool(0.01) {
-                        Err(io::Error::new(io::ErrorKind::Other, "worker closed"))
-                    } else {
-                        Ok(())
-                    }
-                })
-            });
-            let mut c = c.connect(None).await.unwrap();
-
-            let mut rng = rand::rngs::OsRng;
-            let mut random_queues = Vec::from(QUEUES);
-            random_queues.shuffle(&mut rng);
-            for idx in 0..jobs {
-                if idx % 2 == 0 {
-                    // push
-                    let mut job = Job::new(
-                        "SomeJob",
-                        vec![serde_json::Value::from(1), "string".into(), 3.into()],
-                    );
-                    job.priority = Some(rng.gen_range(1..10));
-                    job.queue = QUEUES.choose(&mut rng).unwrap().to_string();
-                    p.enqueue(job).await?;
-                    if pushed.fetch_add(1, atomic::Ordering::SeqCst) >= jobs {
-                        return Ok::<usize, Error>(idx);
-                    }
-                } else {
-                    // pop
-                    c.run_one(0, &random_queues[..]).await?;
-                    if popped.fetch_add(1, atomic::Ordering::SeqCst) >= jobs {
-                        return Ok(idx);
-                    }
-                }
-            }
-            Ok(jobs)
-        });
-    }
-
-    let mut _ops_count = Vec::with_capacity(threads);
-    while let Some(res) = set.join_next().await {
-        _ops_count.push(res.unwrap())
-    }
-
-    let stop = start.elapsed();
-
-    let stop_secs = stop.as_secs() * 1_000_000_000 + u64::from(stop.subsec_nanos());
-    let stop_secs = stop_secs as f64 / 1_000_000_000.0;
-    println!(
-        "Processed {} pushes and {} pops in {:.2} seconds, rate: {} jobs/s",
-        pushed.load(atomic::Ordering::SeqCst),
-        popped.load(atomic::Ordering::SeqCst),
-        stop_secs,
-        jobs as f64 / stop_secs,
-    );
-    println!("{:?}", _ops_count);
+    () /* ~ changed by cargo-mutants ~ */
 }


*** /home/pavel/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo build --tests --manifest-path /tmp/cargo-mutants-faktory-rs-3ziugm.tmp/Cargo.toml
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s

*** result: Success

*** /home/pavel/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo test --manifest-path /tmp/cargo-mutants-faktory-rs-3ziugm.tmp/Cargo.toml --locked --all-features --all-targets
   Compiling faktory v0.12.5 (/tmp/cargo-mutants-faktory-rs-3ziugm.tmp)
    Finished test [unoptimized + debuginfo] target(s) in 1.24s
     Running unittests src/lib.rs (target/debug/deps/faktory-248e4bd4cd431a2c)

running 35 tests
test proto::batch::test::test_batch_serialized_correctly ... ok
test proto::single::resp::test::it_decodes_blob_json ... ok
test proto::single::resp::test::it_decodes_json_ok_blob ... ok
test proto::single::ent::test::test_uniqueness_faeture_for_enterprise_faktory ... ok
test proto::single::resp::test::it_cant_do_arrays - should panic ... ok
test proto::batch::test::test_batch_creation ... ok
test proto::single::resp::test::it_decodes_json_empty ... ok
test proto::single::ent::test::test_same_purpose_setters_applied_simultaneously ... ok
test proto::single::ent::test::test_expiration_feature_for_enterprise_faktory ... ok
test proto::single::resp::test::it_decodes_json_nill ... ok
test proto::single::resp::test::it_decodes_json_ok_string ... ok
test proto::single::resp::test::it_decodes_string_json ... ok
test proto::single::resp::test::it_errors_on_unknown_resp_type ... ok
test proto::single::resp::test::it_parses_empty_bulk ... ok
test proto::single::resp::test::it_parses_nills ... ok
test proto::single::resp::test::it_parses_non_empty_bulk ... ok
test proto::single::resp::test::it_parses_errors ... ok
test proto::single::resp::test::it_parses_numbers ... ok
test proto::single::resp::test::it_errors_on_bad_numbers ... ok
test proto::single::resp::test::it_errors_on_bad_json_string ... ok
test proto::single::resp::test::it_errors_on_bad_json_blob ... ok
test proto::single::resp::test::it_errors_on_bad_sizes ... ok
test proto::single::resp::test::it_parses_simple_strings ... ok
test proto::single::resp::test::json_error_on_number ... ok
test proto::single::test::test_all_job_creation_variants_align ... ok
test proto::single::test::test_arbitrary_custom_data_setter ... ok
test proto::single::test::test_job_can_be_created_with_builder ... ok
test proto::utils::tests::correct_env_parsing ... ok
test proto::single::utils::test::test_id_of_known_size_generated ... ok
test proto::utils::tests::url_port_default ... ok
test proto::utils::tests::url_requires_host ... ok
test proto::utils::tests::url_doesnt_require_port ... ok
test proto::utils::tests::url_requires_tcp ... ok
test proto::utils::tests::url_can_take_password_and_port ... ok
test proto::single::utils::test::test_ids_are_unique ... ok

test result: ok. 35 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 3.05s

     Running unittests src/bin/loadtest.rs (target/debug/deps/loadtest-c216a21f6a383186)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/consumer.rs (target/debug/deps/consumer-e1d67c7fdddceb0c)

running 8 tests
test dequeue_first_empty ... ok
test dequeue ... ok
test hello ... ok
test hello_pwd ... ok
test terminate ... ok
test well_behaved ... ok
test no_first_job ... ok
test well_behaved_many ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 10.14s

     Running tests/producer.rs (target/debug/deps/producer-df2a4c85351204eb)

running 4 tests
test queue_control ... ok
test enqueue ... ok
test hello ... ok
test hello_pwd ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s

     Running tests/real/main.rs (target/debug/deps/real-25004b966fe6ecc0)

running 20 tests
test community::fail ... ok
test community::multi ... ok
test enterprise::ent_unique_job ... ok
test community::test_jobs_created_with_builder ... ok
test enterprise::ent_unique_job_until_success ... ok
test community::queue ... ok
test enterprise::ent_unique_job_until_start ... ok
test enterprise::ent_expiring_job ... ok
test enterprise::test_batch_of_jobs_can_be_initiated ... ok
test community::hello_worker ... ok
test enterprise::test_callback_will_not_be_queued_unless_batch_gets_committed ... ok
test community::enqueue_job ... ok
test enterprise::ent_unique_job_bypass_unique_lock ... ok
test community::test_jobs_pushed_in_bulk ... ok
test enterprise::test_callback_will_be_queued_upon_commit_even_if_batch_is_empty ... ok
test community::roundtrip ... ok
test community::hello_client ... ok
test enterprise::test_batches_can_be_nested ... ok
test enterprise::test_batch_can_be_reopened_add_extra_jobs_and_batches_added ... ok
test enterprise::test_tracker_can_send_and_retrieve_job_execution_progress ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.08s

     Running tests/tls.rs (target/debug/deps/tls-5b4e80b3c3ce326a)

running 1 test
test roundtrip_tls ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


*** result: Success
